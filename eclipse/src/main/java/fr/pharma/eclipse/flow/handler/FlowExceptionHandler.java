package fr.pharma.eclipse.flow.handler;import java.util.Map;import javax.persistence.OptimisticLockException;import javax.persistence.PersistenceException;import javax.validation.ConstraintViolationException;import org.apache.commons.lang.exception.ExceptionUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.webflow.definition.TransitionDefinition;import org.springframework.webflow.engine.FlowExecutionExceptionHandler;import org.springframework.webflow.engine.RequestControlContext;import org.springframework.webflow.engine.Transition;import org.springframework.webflow.engine.TransitionableState;import org.springframework.webflow.engine.support.DefaultTargetStateResolver;import org.springframework.webflow.engine.support.TransitionExecutingFlowExecutionExceptionHandler;import org.springframework.webflow.execution.FlowExecutionException;import fr.pharma.eclipse.exception.ValidationException;/** * Classe de gestion des exceptions retournées par le métier. Cette classe * permet d'intercepter les erreurs de type ValidationException et de les * ajouter à la liste des errors affichages avec la balise 'form:error'. * @author NETAPSYS * @version $Revision$ $Date$ */public class FlowExceptionHandler implements FlowExecutionExceptionHandler {    /**     * Logger par défaut.     */    private final Logger log = LoggerFactory.getLogger(FlowExceptionHandler.class);    /**     * Dictionnaire d'handler en fonction du type de l'exception.     */    private Map<String, ExceptionHandler> handlers;    /**     * {@inheritDoc}     */    @Override    public boolean canHandle(final FlowExecutionException exception) {        return this.findBusinessException(exception) != null;    }    /**     * {@inheritDoc}     */    @Override    public void handle(final FlowExecutionException exception,                       final RequestControlContext context) {        // recherche du handler correspondant à l'exception        final TransitionableState testState = (TransitionableState) context.getCurrentState();        TransitionDefinition transitionDefinition = null;        // check if flowExecutionException is null to avoid looping indefinitely        if (context.getFlashScope().get(TransitionExecutingFlowExecutionExceptionHandler.FLOW_EXECUTION_EXCEPTION_ATTRIBUTE) == null) {            transitionDefinition = testState.getTransition("error");        }        if (transitionDefinition == null) {            // transition not found => fall back to "comeback" page            transitionDefinition = testState.getTransition("comeback");        }        if (transitionDefinition == null) {            // transition not found => fall back to "main" page            transitionDefinition = testState.getTransition("main");        }        this.handlers.get(this.findBusinessException(exception)).handle(exception, context);        context.getFlashScope().put(TransitionExecutingFlowExecutionExceptionHandler.FLOW_EXECUTION_EXCEPTION_ATTRIBUTE, exception);        context.getFlowScope().clear();        context.execute(new Transition(new DefaultTargetStateResolver(transitionDefinition.getTargetStateId())));    }    /**     * Méthode en charge de caster les erreurs à attrapper en ValidationError.     * @param ex Exception.     * @return Erreur de type Validation Erreur.     */    private String findBusinessException(final FlowExecutionException ex) {        if (ExceptionUtils.indexOfThrowable(ex, ValidationException.class) != -1) {            return ValidationException.class.getSimpleName();        }        if (ExceptionUtils.indexOfThrowable(ex, ConstraintViolationException.class) != -1) {            return ConstraintViolationException.class.getSimpleName();        }        if (ExceptionUtils.indexOfThrowable(ex, OptimisticLockException.class) != -1) {            return OptimisticLockException.class.getSimpleName();        }        if (ex.getCause() instanceof PersistenceException) {            final String excep1 = "org.hibernate.TypeMismatchException";            final String excep2 = "org.hibernate.action.DelayedPostInsertIdentifier";            final String msg = ex.getCause().getMessage();            if (msg.contains(excep1) && msg.contains(excep2)) {                return "ConcurrenceException";            }        }        // Erreur non gérée : log.        if (this.log.isErrorEnabled()) {            this.log.error(ExceptionUtils.getFullStackTrace(ex));        }        return null;    }    /**     * Getter sur handlers.     * @return Retourne le handlers.     */    public Map<String, ExceptionHandler> getHandlers() {        return this.handlers;    }    /**     * Setter pour handlers.     * @param handlers le handlers à écrire.     */    public void setHandlers(final Map<String, ExceptionHandler> handlers) {        this.handlers = handlers;    }}